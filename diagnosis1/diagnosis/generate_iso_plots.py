import os
import sys
import cdms2
import numpy
# setting the absolute path of the previous directory
# getting the this py module path by __file__ variable
# pass that __file__ to the os.path.dirname, returns the path of this module
__diagnosisDir__ = os.path.dirname(__file__)
previousDir = os.path.abspath(os.path.join(__diagnosisDir__, '..'))
# adding the previous path to python path
sys.path.append(previousDir)
# importing plot.py, xml_data_acces.py, TimeUtility from previous directory
# uv_cdat_code.diagnosisutils
import uv_cdat_code.diagnosisutils.plot as plot
import uv_cdat_code.diagnosisutils.xml_data_access as xml_data_access
from uv_cdat_code.diagnosisutils.timeutils import TimeUtility
from uv_cdat_code.diagnosisutils.regions import India2
from diag_setup.globalconfig import models, processfilesPath, plotsgraphsPath, \
                               plotLevel, seasons
from diag_setup.varsdict import variables, isovars
from diag_setup.gendir import createDirsIfNotExists

# create time utility object
timobj = TimeUtility()


def genSeasonMeanDirs(modelName, availableMonths, plotLevel):
    """
    :func:`genSeasonMeanDirs`: It should generate the directory hierarichy
        structure of season mean in the plotsgraphspath. And calls the
        function genIsoLinePlots to make 'isoline' plots and save it inside the
        appropirate directory, by reading the xml file of the appropirate
        process season mean files path.

    Inputs : modelName is the one of the directories name.
             availableMonths is the dictionary which is generated by fully
             available months from the timeAxis.

    ..note:: It should takes the levels which is set in the global config
             file and generate the 'isoline' plots to those levels only.

    Written By : Arulalan.T

    Date : 20.09.2011
    Updated: 12.12.2011

    """

    processMeanPath = os.path.join(processfilesPath, modelName, 'Mean')
    for year in availableMonths:
        # get the months dictionary
        monthdic = availableMonths.get(year)
        # sort the months in correct order
        months = timobj._sortMonths(monthdic.keys())
        year = str(year)
        processMeanSeasonPath = os.path.join(processMeanPath, year, 'Season')
        for seasonName, season in seasons.iteritems():
            # find out xml time axis months has the seasonal months or not
            seasonMonths = [month for smonth in season for month in months
                            if smonth[:3].lower() == month[:3].lower()]
            if len(seasonMonths) == len(season):
                print "Got the seasonal months for %s season" % seasonName
            else:
                print "Seasonal months are not available for %s season" % seasonName
                continue
            if seasonName.isupper():
                seasonName = seasonName.lower()
            # get the season startdate to access the data
            seasonStartDate = monthdic.get(months[0])
            proMeanSeasonChildPath = os.path.join(processMeanSeasonPath, seasonName, 'Analysis')
            # Do process if process mean season name directory is exists
            if not os.path.isdir(proMeanSeasonChildPath):
                raise RuntimeError("The process season mean files directories \
                 doesnot exists in the path %s. So couldnt plot the winds" % \
                    proMeanSeasonChildPath)
            # get the available files from this directory
            files = os.listdir(proMeanSeasonChildPath)
            if not files:
                print "Processed season mean directory is empty in the path", proMeanSeasonChildPath
                continue
            # end of if not files:
            ncfiles = [xfile for xfile in files if xfile.endswith('.nc')]
            # make ncfiles as dictionary with key as var name
            ncfiledic = {}
            for ncfile in ncfiles:
                var = ncfile.split('_')[0]
                ncfiledic[var] = ncfile
            # make memory free
            del ncfiles
            # create modelName, Mean, year, Season, seasonName directories
            # if it is not exists
            plotSeasonPath = createDirsIfNotExists(plotsgraphsPath,
                                                [modelName, 'Mean', year,
                                                   'Season', seasonName])
            # get the variable name from the global 'vars.txt'
            # of isovars
            for key in isovars:
                if not key:
                    # skipping empty short_var
                    continue
                if key == 'tmp':
                    plotName = 'TEMPERATURE'
                elif key == 'hum':
                    plotName = 'HUMIDITY'
                elif key == 'mslp':
                    plotName = 'MEAN_SEA_LEVEL_PRESSURE'
                else:
                    plotName = key
                # create plot name directory if it is not exists
                plotNamePath = createDirsIfNotExists(plotSeasonPath,
                                                           plotName)
                if not os.listdir(plotNamePath):
                    # directory is empty. So calling below function to
                    # create all IsoLine plot image files in mean
                    # directory of plotsgraphspath.
                    varName = variables.get(modelName).get(key).model_var
                    if varName:
                        ncfile = ncfiledic.get(varName)
                        print varName, ncfile, ncfiledic
                        # get the xml file path
                        ncPath = proMeanSeasonChildPath + '/' + ncfile
                        genIsoLinePlots(varName, key, path = ncPath,
                              outpath = plotNamePath, month = seasonName,
                              date = seasonStartDate, level = plotLevel,
                              region = India2)
                else:
                    pass
                    # directory is non empty. Have to check either all
                    # vars plots image files are exists or not.
                # end of if not os.listdir(plotNamePath):
            # end of for key in isovars:
        # end of for seasonName, season in seasons.iteritems():
    # end of for year in availableMonths:
    print "Done! creation of isoLine plots of season mean for model %s" % modelName
# end of def genSeasonMeanDirs(modelName, availableMonths):

def genSeasonFcstSysErrDirs(modelName, modelHour, availableMonths, plotLevel):
    """
    :func:`genSeasonFcstSysErrDirs`: It should generate the directory hierarichy
        structure of season fcstsyserr in the plotsgraphspath. And calls the
        function genIsoFillLinePlots to make 'isofillline' plots and save it
        inside the appropirate directory, by reading the xml file of the
        appropirate process season fcstsyserr files path.

        It should plot for all the vars in the 'isovars' which has set in the
        global 'vars.txt' file.

        To plot isoFillLinePlot, this function should find out the isoLevels
        for all the variables of all the levels and all the hours.

        isoLevels : It is a range of levels which is from the min (of data of
            all the hours and levels), to the max (of data of all the hours and
            levels) to set the levels in the vcs plot and legend.

    Inputs : modelName is the one of the directories name.
             modelHour is the one of the directories name.
             availableMonths is the dictionary which is generated by fully
             available months from the timeAxis.

    ..note:: It should takes the levels which is set in the global config
             file, and generate the 'IsoFillLine' plots to those levels only.

    Written By : Arulalan.T

    Date : 20.09.2011
    Updated: 12.12.2011

    """

    processFcstSysErrPath = os.path.join(processfilesPath, modelName, 'FcstSysErr')
    for year in availableMonths.keys():
        # get the months dictionary
        monthdic = availableMonths.get(year)
        # sort the months in correct order
        months = timobj._sortMonths(monthdic.keys())
        year = str(year)
        processFcstSeasonPath = os.path.join(processFcstSysErrPath, year, 'Season')
        for seasonName, season in seasons.iteritems():
            # find out xml time axis months has the seasonal months or not
            seasonMonths = [month for smonth in season for month in months
                            if smonth[:3].lower() == month[:3].lower()]
            if len(seasonMonths) == len(season):
                print "Got the seasonal months for %s season" % seasonName
            else:
                print "Seasonal months are not available for %s season" % seasonName
                continue
            if seasonName.isupper():
                seasonName = seasonName.lower()
            # get the season startdate to access the data
            seasonStartDate = monthdic.get(months[0])
            proFcstSeasonChildPath = os.path.join(processFcstSeasonPath, seasonName)
            ##################################################################
            #### process begins to find out the max & min of all the fcst
            #### hours data to set the isolevels in the legends of
            #### isofillline plots
            # need to find out the max, min of all the hours, all the levels data
            isovarlevels = {}
            for key in isovars:
                if not key:
                    # skipping the empty short_var
                    continue
                # get the variable name from the global 'vars.txt'
                # of isovars
                varName = variables.get(modelName).get(key).model_var
                if not varName:
                    # skipping the empty varName
                    continue
                print "Calculating the isoLevels for (%s, %s)" % (key, varName)
                # find out the max and min of all the hours of variable

                for hr in modelHour:
                    # get the process fcstsyserr hour path
                    proFcstHrPath = os.path.join(proFcstSeasonChildPath, hr)
                    # Do process if process fcstsyserr hour directory is exists
                    if not os.path.isdir(proFcstHrPath):
                        print "the %s hour process path doesnot exist in the \
                            path %s. So skipping find max,min of season " % (hr, proFcstHrPath)
                        continue
                    # get the available files from this directory
                    files = os.listdir(proFcstHrPath)
                    if not files:
                        # skipping the empty dir
                        continue
                    # get the nc file name
                    ncfiles = [xfile for xfile in files if xfile.endswith('.nc')]
                    if not ncfiles:
                        # skipping the empty ncfiles
                        continue
                    # make ncfiles as dictionary with key as var name
                    ncfiledic = {}
                    for ncfile in ncfiles:
                        var = ncfile.split('_')[0]
                        ncfiledic[var] = ncfile
                    # make memory free
                    del ncfiles
                    # get the nc file path
                    ncfile = ncfiledic.get(varName)
                    ncPath = proFcstHrPath + '/' + ncfile
                    # open the ncfile
                    F = cdms2.open(ncPath)
                    availableLevels = F[varName].getLevel()
                    # making None list if availableLevels is none.
                    if not availableLevels:
                        availableLevels = [None]
                    if plotLevel == 'all':
                        print "plotlevl is 'all'. So it takes all the \
                                availableLevels  %s to calculate the \
                                isoLevels" % str(availableLevels)
                        plotLevel = availableLevels
                    # end of if plotLevel == 'all':

                    # To find out the max of all the data including timeAxis
                    # & levelAxis.we can easily do that by MV2_array.max().
                    # But due to efficiency of RAM memory while retriving
                    # the whole seasonal data, we are splitting it into
                    # levels to get the max of that level data. Finally
                    # find out the max of all the max of all the levels.
                    # Samething procedure for min also.
                    maxcollection, mincollection = [], []
                    for lev in plotLevel:
                        if lev:
                            lev = float(lev)
                            if lev in availableLevels:
                                # extract region part alone with particular level
                                VAR = F(varName, India2, level = lev, squeeze = 1)
                        else:
                            # extract region part alone without level
                            VAR = F(varName, India2, squeeze = 1)
                        # end of if lev:
                        maxcollection.append(VAR.max())
                        mincollection.append(VAR.min())
                    # end of for lev in plotLevel:
                F.close()
                # end of for hr in modelHour:
                # find out the max, min of the whole data (including all the
                # hours and levels)
                isomax = max(maxcollection)
                isomin = min(mincollection)
                # find out the diff of max & min, and then divide by 10.0 to make
                # 10 iso levels. So we need to set 10 isocolors.
                cal = (isomax - isomin) / 10.0
                if cal < 1:
                    diff = float(cal)

                    print 'diff=', diff

                    #isomax =
                    # get the isoLevels. This isoLevels are fixed one for the same variable
                    # data for all the levels.
                    # generate the iso levels using numpy.arange (for float range)
#                    isoLevels1 = list(numpyrange(isomin, isomax + diff, diff))
#                    isoLevels=numpy.round(numpy.array(isoLevels1), 2)
#                    isoLevels=list(isoLevels)
                    isoLevels = [-2, -1, -0.5, 0, 0.5, 1, 2, 3]
                    print isoLevels
                else:
                    diff = int(cal)
#                    isoLevels = range(int(isomin), int(isomax) + diff, diff)
                    isoLevels = [-2, -1, -0.5, 0, 0.5, 1, 2, 3]
                # end of if cal < 1:
                isovarlevels[key] = isoLevels
            # end of for key in isovars:
            #### process ends to find out the max & min of all the fcst
            #### hours data to set the isolevels in the legends of
            #### isofillline plots
            ##################################################################

            # plotting isofillline images for all hours
            for hr in modelHour:
                # get the process fcstsyserr hour path
                proFcstHrPath = os.path.join(proFcstSeasonChildPath, hr)
                # Do process if process fcstsyserr hour directory is exists
                if not os.path.isdir(proFcstHrPath):
                    print "the %s hour process path doesnot exist in the \
                            path %s. So skipping isofillline plots " % (hr, proFcstHrPath)
                    continue
                # get the available files from this directory
                files = os.listdir(proFcstHrPath)
                if not files:
                    continue
                    # process empty directory. need to log about this.
                    # process files cant be empty, very less chance.
                # end of if not files:
                # get the nc file name
                ncfiles = [xfile for xfile in files if xfile.endswith('.nc')]
                if not ncfiles:
                    # skipping the empty ncfiles
                    continue
                # make ncfiles as dictionary with key as var name
                ncfiledic = {}
                for ncfile in ncfiles:
                    var = ncfile.split('_')[0]
                    ncfiledic[var] = ncfile
                # make memory free
                del ncfiles
                # create modelName directory if it is not exists
                plotSeasonHrPath = createDirsIfNotExists(plotsgraphsPath,
                                         [modelName, 'FcstSysErr', year,
                                              'Season', seasonName, hr])
                # get the variable name from the global 'vars.txt'
                # of isovars
                for key in isovars:
                    if not key:
                        # skipping empty short_var
                        continue
                    if key == 'tmp':
                        plotName = 'TEMPERATURE'
                    elif key == 'hum':
                        plotName = 'HUMIDITY'
                    elif key == 'mslp':
                        plotName = 'MEAN_SEA_LEVEL_PRESSURE'
                    else:
                        plotName = key
                    # create plot name directory if it is not exists
                    plotNamePath = createDirsIfNotExists(plotSeasonHrPath,
                                                                 plotName)
                    if not os.listdir(plotNamePath):
                        # directory is empty. So calling below function
                        # to create all isofillline plot image files
                        # in fcstsyserr directory of plotsgraphspath.
                        varName = variables.get(modelName).get(key).model_var
                        isolevels = isovarlevels.get(key)
                        if varName:
                            # get the nc file path
                            ncfile = ncfiledic.get(varName)
                            ncPath = proFcstHrPath + '/' + ncfile
                            genIsoFillLinePlots(varName, key, isolevels,
                                    path = ncPath, outpath = plotNamePath,
                                month = seasonName, date = seasonStartDate,
                                level = plotLevel, region = India2)
                        else:
                            print "Skipping %s isovars, since its \
                                    model_var is empty " % key
                    else:
                        pass
                        # directory is non empty. Have to check either
                        # all vars plots image files are exists or not
                    # end of if not os.listdir(plotNamePath):
                # end of for key in isovars:
            # end of for hr in modelHour:
        # end of for seasonName, season in seasons.iteritems():
    # end of for year in availableMonths:
    print "Done! creation of isoFillLine plots of season fcstsyserr for model %s" % modelName
# end of def genSeasonFcstSysErrDirs(modelName, modelHour, availableMonths):

def genIsoLinePlots(var, key, xmlpath=None, path=None, outpath=None,
                                  month=None, date=None, level='all',
                          region=None, svg=0, png=1):
    """
    :func:`genIsoLinePlots`: It should generate the isoLine plots in
            vcs background and save it as png(by default) inside the outpath,
            with isoLevels (find out by this method) and isoColors (default).
    Inputs : var is the variable name.
             key to identify, it is which variable to make plot name.
             xmlpath is the xml file absolute path.
             path is the nc file absolute path.
             pass any one (path or xmlpath)

             outpath is the absolute path, where the generated plots should be
             stored. By default, it is None. It means, it should save in the
             current working directory itself.
             level is either single level, or list of levels or 'all'.
             'all' means, it takes all the availableLevels from the variables.
             level value must be int, float only. Not be string, other than
             'all' keyword.
             region is the region variable which should cut particular region
             shape from the global data. By default it is None, i.e. takes
             global data region itself.

             svg is the flag. If flag is set, then the vector plot should be
             saved as svg formate. By default it is 0.

             png is the flag. If flag is set, then the vector plot should be
             saved as png formate. By default it is 1.

     ..note:: This function should find out the isoLevels to set in the
         isoline plot and its legend in vcs. IsoLevels is the range of min and
         max of all the levels data min and max.

    Written By : Arulalan.T

    Date : 21.09.2011
    Updated: 12.12.2011

    """

    no = 0
    if xmlpath:
        xmlobj = cdms2.open(xmlpath)
        availableLevels = xmlobj[var].getLevel()
        fname = xmlpath.split('/')[-1]
        filelist = fname.split('_')
        if filelist[1] == 'analysis':
            seamon = filelist[2]
            no = 1
    elif path:
        f = cdms2.open(path)
        availableLevels = f[var].getLevel()
        filelist = path.split('/')[-1].split('_')
        fname = filelist[-1]
        xmlpath = None

    else:
        raise("you must pass either xmlpath or path")

    # making None list if availableLevels is none.
    if not availableLevels:
        availableLevels = [None]

    if 'analysis' in filelist:
        processname = 'MEAN ANALYSIS'
    elif 'fcstsyserr' in filelist:
        processname = 'FCST SYS ERR'
    else:
        processname = ''
    seamon = month.upper()
    # modelname
    startname = filelist[1 + no].upper()
    startname = startname.split('.')[0]
    # hour
    hr = filelist[-1].split('.')[0]
    if hr.endswith('hr'):
        # get the forecast hour from the file name
        hr = int((hr.split('hr')[0]).split('f')[1])
        day = hr / 24.0
        # keep as float if day is not 24's multiple
        if not hr % 24.0:
            day = int(day)
        startname += ' ' + 'D0' + str(day)
    # end of if hr.endswith('hr'):
    # add key name
    if key == 'tmp':
        endname = 'TEMPERATURE'
    elif key == 'hum':
        endname = 'HUMIDITY'
    elif key == 'mslp':
        endname = 'MEAN SEA LEVEL PRESSURE'
    else:
        endname = key
    # add season/month name, year
    endname += ' ' + seamon + ' ' + filelist[2 + no]

    if level:
        # if level has passed the over write the global plotLevel
        if isinstance(level, int):
            plotLevel = [level]
        elif isinstance(level, (list, str)):
            plotLevel = level
        else:
            plotLevel = 'all'
    if plotLevel == 'all':
        print "plotlevl is 'all'. So it takes all the availableLevels %s \
                to plot wind vectors" % str(availableLevels)
        plotLevel = availableLevels
        print plotLevel

    # default color list for 11 isoLevels including mid(0) of isoLevels
    isoColors = [250, 244, 25, 246, 255, 253, 251, 252, 254, 166, 248, 249, 210, 239]
    #[22, 247, 244, 243, 240, 253, 245, 248, 242]
    #

    # defining the local function to avoid the repeat the code
    def doIsoLinePlot(VAR, isoColors, plotname, outpath, svg, png):
        # plotting the extracted VAR by finding its levels from it.
        # find out the max, min of the data of this level
        isomax = VAR.max()
        isomin = VAR.min()
        # find out the diff of max & min, and then divide by 10.0 to make
        # 10 iso levels. So we need to set 10 isocolors.
        cal = (isomax - isomin) / 10.0
        if cal < 1:
            diff = float(cal)
            diff=round(diff, 2)
            # get the isoLevels. This isoLevels are fixed one for the same variable
            # data for all the levels.
            # generate the iso levels using numpy.arange (for float range)
            isoLevels = list(numpy.arange(isomin, isomax + diff, diff))
        else:
            diff = int(cal)
            isoLevels = range(int(isomin), int(isomax) + diff, diff)
        print "Plotting IsoLine : ", plotname
        plot.isoLinePlot(VAR, isoLevels, isoColors, plotname, outpath, svg, png)
        # free memory
        del VAR
    # end of def doIsoLinePlot():

    for lev in plotLevel:
        if lev:
            lev = float(lev)
            if lev in availableLevels:
                plotname = startname + ' ' + processname + ' ' + str(int(lev))
                plotname += 'hPa' + ' ' + endname
                if region:
                    # extract the data w.r.t region, time & level
                    if xmlpath:
                        VAR = xmlobj(var, region, time = date, level = lev, squeeze = 1)
                    else:
                        VAR = f(var, region, time = date, level = lev, squeeze = 1)
                else:
                    # extract the data w.r.t time & level
                    if xmlpath:
                        VAR = xmlobj(var, time = date, level = lev, squeeze = 1)
                    else:
                        VAR = f(var, time = date, level = lev, squeeze = 1)
                # calling the local function to plot for all the levels
                doIsoLinePlot(VAR, isoColors, plotname, outpath, svg, png)
            else:
                print "Skipping IsoLine plot for %s level of plotLevel, since \
                       it is not available in the variable" % str(lev)
                continue
        else:
            # level is None. i.e. for some variable doesnot have level axis.
            # eg. mslp. So here get the data without passing level.
            plotname = startname + ' ' + processname + ' ' + endname
            if region:
                # extract the data w.r.t region, time
                if xmlpath:
                    VAR = xmlobj(var, region, time = date, squeeze = 1)
                else:
                    VAR = f(var, region, time = date, squeeze = 1)
            else:
                # extract the data w.r.t time
                if xmlpath:
                    VAR = xmlobj(var, time = date, squeeze = 1)
                else:
                    VAR = f(var, time = date, squeeze = 1)
            # calling the local function to plot for all the levels
            doIsoLinePlot(VAR, isoColors, plotname, outpath, svg, png)
        # end of if lev:
    # end of for lev in plotLevel:
    if xmlpath:
        xmlobj.close()
    else:
        f.close()
# end of def genIsoPlots(...):

def genIsoFillLinePlots(var, key, isoLevels, xmlpath=None, path=None,
                        outpath=None, month=None, date=None, level='all',
                             region=None, svg=0, png=1):
    """
    :func:`genIsoFillLinePlots`: It should generate the isoFillLine plots in
            vcs background and save it as png(by default) inside the outpath,
            with isoLevels (passed by user) and isoColors (default).
    Inputs : var is the variable name.
             key to identify, it is which variable to make plot name.
             isoLevels is the levels to plot isoFillLine and set the legend
             levels in vcs.
             xmlpath is the xml file absolute path.
             path is the nc file absolute path.
             pass any one (path or xmlpath)

             outpath is the absolute path, where the generated plots should be
             stored. By default, it is None. It means, it should save in the
             current working directory itself.
             level is either single level, or list of levels or 'all'.
             'all' means, it takes all the availableLevels from the variables.
             level value must be int, float only. Not be string, other than
             'all' keyword.
             region is the region variable which should cut particular region
             shape from the global data. By default it is None, i.e. takes
             global data region itself.

             svg is the flag. If flag is set, then the vector plot should be
             saved as svg formate. By default it is 0.

             png is the flag. If flag is set, then the vector plot should be
             saved as png formate. By default it is 1.

    Written By : Arulalan.T

    Date : 21.09.2011
    Updated: 12.12.2011

    """

    no = 0
    if xmlpath:
        xmlobj = cdms2.open(xmlpath)
        availableLevels = xmlobj[var].getLevel()
        fname = xmlpath.split('/')[-1]
        filelist = fname.split('_')
        if filelist[1] == 'analysis':
            no = 1
    elif path:
        f = cdms2.open(path)
        availableLevels = f[var].getLevel()
        filelist = path.split('/')[-1].split('_')
        fname = filelist[-1]
        xmlpath = None
    else:
        raise("you must pass either xmlpath or path")
    # making None list if availableLevels is none.
    if not availableLevels:
        availableLevels = [None]

    if 'analysis' in filelist:
        processname = 'MEAN ANALYSIS'
    elif 'fcstsyserr' in filelist:
        processname = 'FCST SYS ERR'
    else:
        processname = ''
    seamon = month.upper()
    # modelname
    startname = filelist[1 + no].upper()
    startname = startname.split('.')[0]
    # hour
    hr = filelist[-1].split('.')[0]
    if hr.endswith('hr'):
        # get the forecast hour from the file name
        hr = int((hr.split('hr')[0]).split('f')[1])
        day = hr / 24.0
        # keep as float if day is not 24's multiple
        if not hr % 24.0:
            day = int(day)
        startname += ' ' + 'D0' + str(day)
    # end of if hr.endswith('hr'):
    # add key name
    if key == 'tmp':
        endname = 'TEMPERATURE'
    elif key == 'hum':
        endname = 'HUMIDITY'
    elif key == 'mslp':
        endname = 'MEAN SEA LEVEL PRESSURE'
    else:
        endname = key
    # add season/month name, year
    endname += ' ' + seamon + ' ' + filelist[2 + no]

    if level:
        # if level has passed the over write the global plotLevel
        if isinstance(level, int):
            plotLevel = [level]
        elif isinstance(level, (list, str)):
            plotLevel = level
        else:
            plotLevel = 'all'
    if plotLevel == 'all':
        print "plotlevl is 'all'. So it takes all the availableLevels %s \
                to plot wind vectors" % str(availableLevels)
        plotLevel = availableLevels

    # default color list for 11 isoLevels including mid(0) of isoLevels
    isoColors = [250, 244, 25, 246, 255, 253, 251, 252, 254, 166, 248, 249, 210, 239]
    #[22, 247, 244, 243, 240, 253, 245, 248, 242]
    


    for lev in plotLevel:
        if lev:
            lev = float(lev)
            if lev in availableLevels:
                plotname = startname + ' ' + processname + ' ' + str(int(lev))
                plotname += 'hPa' + ' ' + endname
                if region:
                    # extract the data w.r.t region, time & level
                    if xmlpath:
                        VAR = xmlobj(var, region, time = date, level = lev, squeeze = 1)
                    else:
                        VAR = f(var, region, time = date, level = lev, squeeze = 1)
                else:
                    # extract the data w.r.t time & level
                    if xmlpath:
                        VAR = xmlobj(var, time = date, level = lev, squeeze = 1)
                    else:
                        VAR = f(var, time = date, level = lev, squeeze = 1)
                print "Plotting IsoFillLine : ", plotname
                plot.isoFillLinePlot(VAR, isoLevels, isoColors, plotname, outpath, svg, png)
                # free memory
                del VAR
            else:
                print "Skipping IsoLine plot for %s level of plotLevel, since \
                       it is not available in the variable" % str(lev)
            # end of if lev in availableLevels:
        else:
            # level is None. i.e. for some variable doesnot have level axis.
            # eg. mslp. So here get the data without passing level.
            plotname = startname + ' ' + processname + ' ' + endname
            if region:
                # extract the data w.r.t region, time
                if xmlpath:
                    VAR = xmlobj(var, region, time = date, squeeze = 1)
                else:
                    VAR = f(var, region, time = date, squeeze = 1)
            else:
                # extract the data w.r.t time
                if xmlpath:
                    VAR = xmlobj(var, time = date, squeeze = 1)
                else:
                    VAR = f(var, time = date, squeeze = 1)
            print "Plotting IsoFillLine : ", plotname
            plot.isoFillLinePlot(VAR, isoLevels, isoColors, plotname, outpath, svg, png)
            # free memory
            del VAR
        # end of if lev:
    if xmlpath:
        xmlobj.close()
    else:
        f.close()
# end of def genIsoFillLinePlots(...):

if __name__ == '__main__':

    for Model in models:
        xmlobj = xml_data_access.GribXmlAccess(Model.path)
        # get the model variable name from the global 'vars.txt'
        mvar = variables.get(Model.name).values()[0].model_var
        modeldataset = xmlobj[mvar, 'a']
        # get the timeAxis of modeldata set and correct its bounds
        modeltime = timobj._correctTimeAxis(modeldataset.getTime())
        # get the fully available months
        availableMonths = timobj.getTimeAxisFullMonths(modeltime)
        # calling func to geneate season mean directories and its plots
        genSeasonMeanDirs(Model.name, availableMonths, plotLevel)
        # calling func to geneate season fcstsyserr directories and its plots
        genSeasonFcstSysErrDirs(Model.name, Model.hour, availableMonths, plotLevel)
        # close the xml objects
        xmlobj.closeXmlObjs()
    # end of for model in models:
    print "Done! Creation of all vector plots"
# end of if __name__ == '__main__':
